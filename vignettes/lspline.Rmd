---
title: "Piecewise-linear splines"
author: "MichaÅ‚ Bojanowski"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{plinear}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Function `lspline::lspline()` enables to fit piecewise-linear regression effect parametrized such that changes in slope can be tested directly.

```{r load_package}
library(lspline)
```

# Artificial data

Let us generate some artificial data first.

```{r data}
set.seed(666)
n <- 200
d <- data.frame(
  x = runif(n) * 20
)
d$ints <- findInterval(d$x, c(5, 10), rightmost.closed = TRUE) + 1
d$slope <- c(2, -3, 0)[d$ints]
d$intercept <- c(0, 25, -5)[d$ints]
d$y <- with(d, intercept + slope * x + rnorm(n, 0, 1))
```

We have a data frame `d` with `x` and `y` such that

- $y = 2 x$ if $x \in (-\infty, 5]$ 
- $y = -3 x + 25$ if $x \in (5, 10)$
- $y = -5$ if $x \in (10, \infty)$

Essentially it is generated from a linear spline with knots at $x=5$ and $x=10$. The consecutive segments
have slopes 2, -3, and 0. The model has $\sigma = 1$.

Plotting `y` against `x` gives:

```{r show_data}
plot( y ~ x, col=ints, data=d)
```

# Recovering segment slopes (`marginal = FALSE`)

We can recover the data-generating model by fitting a linear model with a linear spline. Function `lspline` expects the input vector and argument `knots` with a vector of the positions of the knots. Using argument `marginal` set to `FALSE` (which is the default) creates the basis in such a way that the regression coefficients will correspond to slopes of consecutive segments:

```{r lspline_nonmarginal}
mod1 <- lm( y ~ lspline(x, c(5, 10), marginal=FALSE), data=d)
summary(mod1)
```

The coeficients are close enough to the values used to generate the data.








# Testing slope change (`marginal = TRUE`)


Below the spline will have knots at 5 and 10.

Notice that original `x` is also included in the model.

```{r lspline_marginal}
mod2 <- lm( y ~ lspline(x, c(5, 10), marginal=TRUE), data=d)
summary(mod2)
```

The coefficients have the following interpretation:

- Intercept - as usual.
- `x` - the slope of `x` in the first interval
- `plinear(x, 5, 10).x>5` - the **change** in slope of `x` in the **second** interval as compared to the **first**. That slope in the second interval is approx. `r coef(mod2)[2]` + `r coef(mod2)[3]` = `r sum(coef(mod2)[2:3])`.
- `plinear(x, 5, 10).x>10` - the **change** in slope of `x` in the **third** interval as compared to the **second**. The slope in the third interval is approx `r coef(mod2)[2]` + `r coef(mod2)[3]` + `r coef(mod2)[4]` = `r sum(coef(mod2)[2:4])`.

So almost identical to the original slopes of 2, -3, and 0.







# Data and fitted values

Both models have identical fitted values

```{r equal_fitted_values}
all.equal(fitted(mod1), fitted(mod2))
```

```{r test_equal_fitted_values, include=FALSE}
stopifnot(all.equal(fitted(mod1), fitted(mod2)))
```



as can be also inspected on the following picture.

```{r plot_fitted}
d$f <- fitted(mod1)
d <- d[order(d$x),]

plot(y ~ x, col=adjustcolor(ints, 0.5), data=d)
points(f ~ x, col="navyblue", data=d)
```
